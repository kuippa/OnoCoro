Change Type: significant_change
ILSpy: g:\unity\OnoCoro2026\Assets\Recovery\.Editor\ILspy_CS\PlateauCubeMaker.cs
Scripts: g:\unity\OnoCoro2026\Assets\Scripts\Plateau\PlateauCubeMaker.cs
================================================================================

--- PlateauCubeMaker.cs+++ PlateauCubeMaker.cs@@ -1,200 +1,188 @@-// Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
-// PlateauCubeMaker
-using System;
+using UnityEngine;
 using System.Collections.Generic;
 using CommonsUtility;
-using UnityEngine;
 
 public class PlateauCubeMaker : MonoBehaviour
 {
-	private const float _CENTER_Y_OFFSET = 5f;
+    const float _CENTER_Y_OFFSET = 5.0f;
+    const float _BUFFER_Y_OFFSET = 0.5f;
 
-	private const float _BUFFER_Y_OFFSET = 0.5f;
+    internal void BreakUpBuildingCube(GameObject targetObj, int rebuildCost)
+    {
+        // rebuildCost 分のゴミを生成
+        int total_score = 0;
+        int i = 0;
+        
+        // MeshFilter meshFilter = targetObj.GetComponent<MeshFilter>();
+        // if (meshFilter == null)
+        // {
+        //     return;
+        // }
+        Renderer renderer = targetObj.GetComponent<Renderer>();
+        Vector3 center = renderer.bounds.center;
+        Vector3 extents = renderer.bounds.extents;
 
-	private const int _MAX_GARBAGE = 200;
+        while (total_score < rebuildCost)
+        {
+            total_score += CreateGarbageRoundByAngle(center, extents, 24, i);
+            i++;
+            if (i > 100)
+            {
+                Debug.Log("i > 100");
+                break;
+            }
+        }
+    }
 
-	private const int _BURNING_BOOST = 10;
+    private int CreateGarbageRoundByAngle(Vector3 center, Vector3 extents, int step, int i)
+    {
+        int total_score = 0;
+        float r = GetRadius(extents);
+        float angle = 360.0f / step;
+        float radian = angle * Mathf.Deg2Rad;
+        // for (int i = 0; i < step; i++)
+        // {
+            float x1 = r * Mathf.Cos(radian * i);
+            float z1 = r * Mathf.Sin(radian * i);
+            Vector3 pos = new Vector3(center.x + x1, center.y + _BUFFER_Y_OFFSET, center.z + z1);
+            // GameObject garbage = GarbageCubeCtrl.SpawnGarbageCube(pos, GarbageCubeCtrl._SIZE_SMALL, true);
+            GameObject garbage = GarbageCubeCtrl.SpawnGarbageCube(pos, GarbageCubeCtrl._SIZE_NORMAL, false);
+            Collider collider = garbage.GetComponent<Collider>();
+            if (collider != null)
+            {
+                total_score += ScoreCtrl.GetTotalGarbageScore(collider);
+            }
+//         }
+        return total_score;
+    }
 
-	private static int GetAngleSpacing(int rebuildCost)
-	{
-		int num = 1;
-		if (rebuildCost < 100)
-		{
-			return 93;
-		}
-		if (rebuildCost < 200)
-		{
-			return 43;
-		}
-		return 23;
-	}
+    internal void DispCubeMarker(GameObject gameObject, Dictionary<string, string> dictInfo)
+    {
+            float height = GetMesuredHeight(dictInfo);
+            GetMeshrenderInfo(gameObject, height);
+    }
 
-	internal void BreakUpBuildingCube(GameObject targetObj, int rebuildCost)
-	{
-		int num = 0;
-		int num2 = 0;
-		int num3 = 1;
-		Renderer component = targetObj.GetComponent<Renderer>();
-		Vector3 center = component.bounds.center;
-		Vector3 extents = component.bounds.extents;
-		rebuildCost *= 10;
-		num3 = GetAngleSpacing(rebuildCost);
-		while (num < rebuildCost)
-		{
-			num += CreateGarbageRoundByAngle(center, extents, num3, num2);
-			num2++;
-			if (num2 > 200)
-			{
-				break;
-			}
-		}
-	}
+    private float GetMesuredHeight(Dictionary<string, string> dictInfo)
+    {
+        float height = 0; 
+        // bldg:measuredheight, value: 7.2
+        if (dictInfo.ContainsKey("bldg:measuredheight"))
+        {
+            height = float.Parse(dictInfo["bldg:measuredheight"]);
+        }
+        return height;
+    }
 
-	private int CreateGarbageRoundByAngle(Vector3 center, Vector3 extents, int step, int i)
-	{
-		float radius = GetRadius(extents);
-		float num = (float)step * (MathF.PI / 180f);
-		float num2 = radius * Mathf.Cos(num * (float)i);
-		float num3 = radius * Mathf.Sin(num * (float)i);
-		float num4 = Mathf.PerlinNoise(num2 * 0.1f, num3 * 0.1f) * 0.5f;
-		num2 += num4;
-		num3 += num4;
-		Vector3 pos = new Vector3(center.x + num2, center.y + 0.5f, center.z + num3);
-		return CreateGarbageCubeSmall(pos);
-	}
+    private void GetMeshrenderInfo(GameObject targetObj, float height = _CENTER_Y_OFFSET)
+    {
+        MeshFilter meshFilter = targetObj.GetComponent<MeshFilter>();
+        if (meshFilter != null)
+        {
+            Renderer renderer = targetObj.GetComponent<Renderer>();
+            SetCubeMark(renderer, height);
+            // CreateCubeRoundByAngle(renderer.bounds.center, renderer.bounds.extents, 16);
+            CreateCubeRoundByArc(renderer.bounds.center, renderer.bounds.extents, 4);
+        }
+        else
+        {
+            Debug.Log("MeshFilter not found"+ targetObj.name);
+        }
+    }
 
-	private int CreateGarbageCubeNormal(Vector3 pos)
-	{
-		int num = 0;
-		Collider component = GarbageCubeCtrl.SpawnGarbageCube(pos).GetComponent<Collider>();
-		if (component != null)
-		{
-			num += ScoreCtrl.GetTotalGarbageScore(component);
-		}
-		return num;
-	}
+    private void SetCubeMark(Renderer renderer, float height)
+    {
+        Vector3 center = renderer.bounds.center;
+        SetCubeAtCenter(center, Color.blue, height);
+        SetCubeAtCorner(renderer);
+    }
 
-	private int CreateGarbageCubeSmall(Vector3 pos)
-	{
-		GameObject gameManagerObject = GameObjectTreat.GetGameManagerObject();
-		GarbageCubeCtrl garbageCubeCtrl = gameManagerObject.GetComponent<GarbageCubeCtrl>();
-		if (garbageCubeCtrl == null)
-		{
-			garbageCubeCtrl = gameManagerObject.AddComponent<GarbageCubeCtrl>();
-		}
-		garbageCubeCtrl.SpawnGarbageCubeAsync(pos, 1, isSwayingPoint: true);
-		return GarbageCube.GetBaseScore();
-	}
+    private void SetCubeAtCorner(Renderer renderer)
+    {
+        Vector3 center = renderer.bounds.center;
+        // 四隅をポイント
+        Vector3 extents1 = renderer.bounds.extents;
+        extents1 = center + extents1;
+        extents1.y = center.y;
+        Vector3 extents2 = renderer.bounds.extents;
+        extents2 = center - extents2;
+        extents2.y = center.y;
+        Vector3 extents3 = renderer.bounds.extents;
+        extents3.x = center.x + extents3.x;
+        extents3.z = center.z - extents3.z;
+        extents3.y = center.y;
+        Vector3 extents4 = renderer.bounds.extents;
+        extents4.x = center.x - extents4.x;
+        extents4.z = center.z + extents4.z;
+        extents4.y = center.y;
 
-	internal void DispCubeMarker(GameObject gameObject, Dictionary<string, string> dictInfo)
-	{
-		float mesuredHeight = GetMesuredHeight(dictInfo);
-		GetMeshrenderInfo(gameObject, mesuredHeight);
-	}
+        // SetCube(extents1, Color.black);
+        // SetCube(extents2, Color.cyan);
+        // SetCube(extents3, Color.magenta);
+        // SetCube(extents4, Color.yellow);
+    }
 
-	private float GetMesuredHeight(Dictionary<string, string> dictInfo)
-	{
-		float result = 0f;
-		if (dictInfo.ContainsKey("bldg:measuredheight"))
-		{
-			result = float.Parse(dictInfo["bldg:measuredheight"]);
-		}
-		return result;
-	}
+    private void SetCubeAtCenter(Vector3 center, Color color, float height)
+    {
+        center.y += height  * 0.5f + _BUFFER_Y_OFFSET;
+        SetCube(center, color);
+    }
 
-	private void GetMeshrenderInfo(GameObject targetObj, float height = 5f)
-	{
-		if (targetObj.GetComponent<MeshFilter>() != null)
-		{
-			Renderer component = targetObj.GetComponent<Renderer>();
-			SetCubeMark(component, height);
-			CreateCubeRoundByArc(component.bounds.center, component.bounds.extents, 4);
-		}
-		else
-		{
-			Debug.Log("MeshFilter not found" + targetObj.name);
-		}
-	}
 
-	private void SetCubeMark(Renderer renderer, float height)
-	{
-		Vector3 center = renderer.bounds.center;
-		SetCubeAtCenter(center, Color.blue, height);
-		SetCubeAtCorner(renderer);
-	}
+    private float GetRadius(Vector3 extents)
+    {
+        float x = extents.x;
+        float z = extents.z;
+        float r = Mathf.Sqrt(x * x + z * z);
+        return r;
+    }
 
-	private void SetCubeAtCorner(Renderer renderer)
-	{
-		Vector3 center = renderer.bounds.center;
-		Vector3 extents = renderer.bounds.extents;
-		extents = center + extents;
-		extents.y = center.y;
-		Vector3 extents2 = renderer.bounds.extents;
-		extents2 = center - extents2;
-		extents2.y = center.y;
-		Vector3 extents3 = renderer.bounds.extents;
-		extents3.x = center.x + extents3.x;
-		extents3.z = center.z - extents3.z;
-		extents3.y = center.y;
-		Vector3 extents4 = renderer.bounds.extents;
-		extents4.x = center.x - extents4.x;
-		extents4.z = center.z + extents4.z;
-		extents4.y = center.y;
-		SetCube(extents, Color.black);
-		SetCube(extents2, Color.cyan);
-		SetCube(extents3, Color.magenta);
-		SetCube(extents4, Color.yellow);
-	}
+    private void CreateCubeRoundByArc(Vector3 center, Vector3 extents, int interval)
+    {
+        float r = GetRadius(extents);
+        float arc = 2.0f * Mathf.PI * r;
+        int step = Mathf.FloorToInt(arc / interval);
+        CreateCubeRoundByAngle(center, extents, step);
+    }
 
-	private void SetCubeAtCenter(Vector3 center, Color color, float height)
-	{
-		center.y += height * 0.5f + 0.5f;
-		SetCube(center, color);
-	}
+    private void CreateCubeRoundByAngle(Vector3 center, Vector3 extents, int step)
+    {
+        float r = GetRadius(extents);
+        float angle = 360.0f / step;
+        float radian = angle * Mathf.Deg2Rad;
+        for (int i = 0; i < step; i++)
+        {
+            float x1 = r * Mathf.Cos(radian * i);
+            float z1 = r * Mathf.Sin(radian * i);
+            Vector3 pos = new Vector3(center.x + x1, center.y + _BUFFER_Y_OFFSET, center.z + z1);
+            SetCube(pos, Color.white);
+            // SetBonFire(pos);
+        }
+    }
 
-	private float GetRadius(Vector3 extents)
-	{
-		float x = extents.x;
-		float z = extents.z;
-		return Mathf.Sqrt(x * x + z * z);
-	}
+    private void SetMaterialColor(GameObject targetObj, Color color)
+    {
+        Renderer renderer = targetObj.GetComponent<Renderer>();
+        if (renderer == null)
+        {
+            return;
+        }
+        if (renderer.materials.Length > 1)
+        {
+            // Debug.Log("material 複数パターン");
+            return;
+        }
+        renderer.material.color = color;
+    }
 
-	private void CreateCubeRoundByArc(Vector3 center, Vector3 extents, int interval)
-	{
-		float radius = GetRadius(extents);
-		int step = Mathf.FloorToInt(MathF.PI * 2f * radius / (float)interval);
-		CreateCubeRoundByAngle(center, extents, step);
-	}
+    private void SetCube(Vector3 setPosition, Color color)
+    {
+        GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
+        cube.transform.position = setPosition;
+        SetMaterialColor(cube, color);
+        cube.AddComponent<Rigidbody>();
+        cube.GetComponent<Rigidbody>().useGravity = true;
+        cube.tag = GameEnum.TagType.Garbage.ToString();
+    }
 
-	private void CreateCubeRoundByAngle(Vector3 center, Vector3 extents, int step)
-	{
-		float radius = GetRadius(extents);
-		float num = 360f / (float)step * (MathF.PI / 180f);
-		for (int i = 0; i < step; i++)
-		{
-			float num2 = radius * Mathf.Cos(num * (float)i);
-			float num3 = radius * Mathf.Sin(num * (float)i);
-			Vector3 setPosition = new Vector3(center.x + num2, center.y + 0.5f, center.z + num3);
-			SetCube(setPosition, Color.white);
-		}
-	}
 
-	private void SetMaterialColor(GameObject targetObj, Color color)
-	{
-		Renderer component = targetObj.GetComponent<Renderer>();
-		if (!(component == null) && component.materials.Length <= 1)
-		{
-			component.material.color = color;
-		}
-	}
-
-	private void SetCube(Vector3 setPosition, Color color)
-	{
-		GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
-		gameObject.transform.position = setPosition;
-		SetMaterialColor(gameObject, color);
-		gameObject.AddComponent<Rigidbody>();
-		gameObject.GetComponent<Rigidbody>().useGravity = true;
-		gameObject.tag = GameEnum.TagType.Garbage.ToString();
-	}
 }


================================================================================
Significant Changes: 314
-	private const float _CENTER_Y_OFFSET = 5f;

+    const float _CENTER_Y_OFFSET = 5.0f;

+    const float _BUFFER_Y_OFFSET = 0.5f;

-	private const float _BUFFER_Y_OFFSET = 0.5f;

+    internal void BreakUpBuildingCube(GameObject targetObj, int rebuildCost)

+    {

+        int total_score = 0;

+        int i = 0;

+        Renderer renderer = targetObj.GetComponent<Renderer>();

+        Vector3 center = renderer.bounds.center;

+        Vector3 extents = renderer.bounds.extents;

-	private const int _MAX_GARBAGE = 200;

+        while (total_score < rebuildCost)

+        {

+            total_score += CreateGarbageRoundByAngle(center, extents, 24, i);

+            i++;

+            if (i > 100)

+            {

+                Debug.Log("i > 100");

+                break;

