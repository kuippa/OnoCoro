Change Type: significant_change
ILSpy: g:\unity\OnoCoro2026\Assets\Recovery\.Editor\ILspy_CS\CircularIndicator.cs
Scripts: g:\unity\OnoCoro2026\Assets\Scripts\UI\CircularIndicator.cs
================================================================================

--- CircularIndicator.cs+++ CircularIndicator.cs@@ -1,147 +1,164 @@-// Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
-// CircularIndicator
+using UnityEngine;
+using UnityEngine.Rendering;
+using UnityEngine.UI;
+using System.Collections;
+// using System.Collections.Generic;
 using System;
-using System.Collections;
 using CommonsUtility;
-using TMPro;
-using UnityEngine;
 
 public class CircularIndicator : MonoBehaviour
 {
-	private float _innerRadius = 0.8f;
+    private float _innerRadius = 0.8f;
+    private float _outerRadius = 1.2f;
+    private int _segments = 360;  // 多角形の頂点数
+    private float _duration = 5f;
+    private Color _filledColor = Color.green;
+    private Mesh _mesh;
+    private float _currentTime = 0f;
+    private bool _isRunning = false;
+    private MeshRenderer _meshRenderer;
+    // private Text _timeText;
+    private TextMesh _textMesh;
+    private Action _onCompleteCallback;  // コールバック関数を保持する変数
 
-	private float _outerRadius = 1.2f;
 
-	private int _segments = 360;
+    private void Awake()
+    {
+        // GameObject txtTime = this.gameObject.transform.Find("Canvas/txtTime").gameObject;
+        // txtTime.SetActive(false);
+        // _timeText = txtTime.GetComponent<Text>();
+        // _timeText.text = _duration.ToString("F1");
 
-	private float _duration = 5f;
+        GameObject cvsTime = this.gameObject.transform.Find("txtMesh").gameObject;        
+        cvsTime.SetActive(false);
+        _textMesh = cvsTime.GetComponent<TextMesh>();
+        _textMesh.text = _duration.ToString("F1");
 
-	private Color _filledColor = Color.green;
+        _mesh = new Mesh();
+        _mesh.name = "CircularRibbonMesh";
+        this.GetComponent<MeshFilter>().mesh = _mesh;
+        _meshRenderer = this.GetComponent<MeshRenderer>();
+        _filledColor = _meshRenderer.material.color;
+        CreateMesh();
 
-	private Mesh _mesh;
+        StartIndicator(_duration, null, this.gameObject);
+    }
 
-	private float _currentTime;
+    private void CreateMesh(int startAngle = 0, int endAngle = 360)
+    {
+        Vector3[] vertices = new Vector3[_segments * 2];
+        int[] triangles = new int[_segments * 6];
+        Vector2[] uv = new Vector2[_segments * 2];
+        Color[] colors = new Color[_segments * 2];
 
-	private bool _isRunning;
+        for (int i = startAngle; i < endAngle; i++)
+        {
+            float angle = i * Mathf.PI * 2f / _segments;
+            float x = Mathf.Sin(angle);
+            float y = Mathf.Cos(angle);
 
-	private MeshRenderer _meshRenderer;
+            vertices[i * 2] = new Vector3(x * _innerRadius, y * _innerRadius, 0);
+            vertices[i * 2 + 1] = new Vector3(x * _outerRadius, y * _outerRadius, 0);
 
-	private TextMeshPro _textMesh;
+            uv[i * 2] = new Vector2((float)i / _segments, 0);
+            uv[i * 2 + 1] = new Vector2((float)i / _segments, 1);
 
-	private Action _onCompleteCallback;
+            if (i < _segments - 1)
+            {
+                triangles[i * 6] = i * 2;
+                triangles[i * 6 + 1] = i * 2 + 1;
+                triangles[i * 6 + 2] = i * 2 + 2;
+                triangles[i * 6 + 3] = i * 2 + 1;
+                triangles[i * 6 + 4] = i * 2 + 3;
+                triangles[i * 6 + 5] = i * 2 + 2;
+            }
+            else
+            {
+                triangles[i * 6] = i * 2;
+                triangles[i * 6 + 1] = i * 2 + 1;
+                triangles[i * 6 + 2] = 0;
+                triangles[i * 6 + 3] = i * 2 + 1;
+                triangles[i * 6 + 4] = 1;
+                triangles[i * 6 + 5] = 0;
+            }
+        }
+        _mesh.vertices = vertices;
+        _mesh.triangles = triangles;
+        _mesh.uv = uv;
+        if (_meshRenderer.materials != null) {
+            // _meshRenderer.material.color = UnityEngine.Random.ColorHSV(0f, 1f, 0f, 1f, 0f, 1f, 0.5f, 0.5f);
+            _meshRenderer.material.color = _filledColor;
+        }
+    }
 
-	private void Awake()
-	{
-		GameObject gameObject = base.gameObject.transform.Find("tmpMesh").gameObject;
-		gameObject.SetActive(value: false);
-		_textMesh = gameObject.GetComponent<TextMeshPro>();
-		_textMesh.text = _duration.ToString("F1");
-		_mesh = new Mesh();
-		_mesh.name = "CircularRibbonMesh";
-		GetComponent<MeshFilter>().mesh = _mesh;
-		_meshRenderer = GetComponent<MeshRenderer>();
-		_filledColor = _meshRenderer.material.color;
-		CreateMesh();
-		StartIndicator(_duration, null, base.gameObject);
-	}
+    private void SetTimeText(float time)
+    {
+        // _timeText.gameObject.SetActive(true);
+        // _timeText.text = time.ToString("F1");
+        _textMesh.gameObject.SetActive(true);
+        _textMesh.text = time.ToString("F1");
+    }
 
-	private void CreateMesh(int startAngle = 0, int endAngle = 360)
-	{
-		Vector3[] array = new Vector3[_segments * 2];
-		int[] array2 = new int[_segments * 6];
-		Vector2[] array3 = new Vector2[_segments * 2];
-		_ = new Color[_segments * 2];
-		for (int i = startAngle; i < endAngle; i++)
-		{
-			float f = (float)i * MathF.PI * 2f / (float)_segments;
-			float num = Mathf.Sin(f);
-			float num2 = Mathf.Cos(f);
-			array[i * 2] = new Vector3(num * _innerRadius, num2 * _innerRadius, 0f);
-			array[i * 2 + 1] = new Vector3(num * _outerRadius, num2 * _outerRadius, 0f);
-			array3[i * 2] = new Vector2((float)i / (float)_segments, 0f);
-			array3[i * 2 + 1] = new Vector2((float)i / (float)_segments, 1f);
-			if (i < _segments - 1)
-			{
-				array2[i * 6] = i * 2;
-				array2[i * 6 + 1] = i * 2 + 1;
-				array2[i * 6 + 2] = i * 2 + 2;
-				array2[i * 6 + 3] = i * 2 + 1;
-				array2[i * 6 + 4] = i * 2 + 3;
-				array2[i * 6 + 5] = i * 2 + 2;
-			}
-			else
-			{
-				array2[i * 6] = i * 2;
-				array2[i * 6 + 1] = i * 2 + 1;
-				array2[i * 6 + 2] = 0;
-				array2[i * 6 + 3] = i * 2 + 1;
-				array2[i * 6 + 4] = 1;
-				array2[i * 6 + 5] = 0;
-			}
-		}
-		_mesh.vertices = array;
-		_mesh.triangles = array2;
-		_mesh.uv = array3;
-		if (_meshRenderer.materials != null)
-		{
-			_meshRenderer.material.color = _filledColor;
-		}
-	}
+    private void UpdateMesh(float fillAmount)
+    {
+        Color[] colors = new Color[_segments * 2];
+        int fillSegments = Mathf.RoundToInt(fillAmount * _segments);
+        CreateMesh(0, fillSegments);
+    }
 
-	private void SetTimeText(float time)
-	{
-		_textMesh.gameObject.SetActive(value: true);
-		_textMesh.text = time.ToString("F1");
-	}
+    internal void StartIndicator(float duration, Action onCompleteCallback = null, GameObject parent = null)
+    {
 
-	private void UpdateMesh(float fillAmount)
-	{
-		_ = new Color[_segments * 2];
-		int endAngle = Mathf.RoundToInt(fillAmount * (float)_segments);
-		CreateMesh(0, endAngle);
-	}
+        this.transform.SetParent(parent.transform, false);
 
-	internal void StartIndicator(float duration, Action onCompleteCallback = null, GameObject parent = null)
-	{
-		base.transform.SetParent(parent.transform, worldPositionStays: false);
-		_duration = duration;
-		_onCompleteCallback = onCompleteCallback;
-		StartFill();
-	}
+        _duration = duration;
+        _onCompleteCallback = onCompleteCallback;  // コールバックを保存
+        StartFill();
+    }
 
-	private void StartFill()
-	{
-		_currentTime = 0f;
-		_isRunning = true;
-	}
+    private void StartFill()
+    {
+        _currentTime = 0f;
+        _isRunning = true;
+    }
 
-	private void ToggleColors()
-	{
-		_filledColor = UnityEngine.Random.ColorHSV();
-		UpdateMesh(_currentTime / _duration);
-	}
+    // テスト用：色を切り替える関数
+    private void ToggleColors()
+    {
+        _filledColor = UnityEngine.Random.ColorHSV();
+        UpdateMesh(_currentTime / _duration);
+    }
 
-	private IEnumerator DelayMethod(float waitTime)
-	{
-		yield return new WaitForSeconds(waitTime);
-		_onCompleteCallback?.Invoke();
-		_mesh.Clear();
-		GameObjectTreat.DestroyAll(base.gameObject);
-	}
+    private IEnumerator DelayMethod(float waitTime)
+    {
+        yield return new WaitForSeconds(waitTime);
+        // コールバックがセットされている場合は実行
+        _onCompleteCallback?.Invoke();
+        _mesh.Clear();
+        GameObjectTreat.DestroyAll(this.gameObject);
+    }
 
-	private void Update()
-	{
-		if (_isRunning)
-		{
-			_currentTime += Time.deltaTime;
-			float num = Mathf.Clamp01(_currentTime / _duration);
-			UpdateMesh(num);
-			SetTimeText(_duration - _currentTime);
-			if (num >= 1f)
-			{
-				StartCoroutine(DelayMethod(0.2f));
-				_isRunning = false;
-			}
-		}
-	}
+    private void Update()
+    {
+        if (_isRunning)
+        {
+            _currentTime += Time.deltaTime;
+            float fillAmount = Mathf.Clamp01(_currentTime / _duration);
+            UpdateMesh(fillAmount);
+            SetTimeText(_duration - _currentTime);
+            if (fillAmount >= 1f)
+            {
+                // 遅延してこのオブジェクトを破棄する
+                StartCoroutine(DelayMethod(0.2f));
+
+                _isRunning = false;
+            }
+        }
+
+        // テスト用：スペースキーを押すと色が切り替わる
+        // if (Input.GetKeyDown(KeyCode.Space))
+        // {
+        //     ToggleColors();
+        // }
+    }
 }


================================================================================
Significant Changes: 233
-	private float _innerRadius = 0.8f;

+    private float _innerRadius = 0.8f;

+    private float _outerRadius = 1.2f;

+    private int _segments = 360;  // 多角形の頂点数

+    private float _duration = 5f;

+    private Color _filledColor = Color.green;

+    private Mesh _mesh;

+    private float _currentTime = 0f;

+    private bool _isRunning = false;

+    private MeshRenderer _meshRenderer;

+    private TextMesh _textMesh;

+    private Action _onCompleteCallback;  // コールバック関数を保持する変数

-	private float _outerRadius = 1.2f;

-	private int _segments = 360;

+    private void Awake()

+    {

-	private float _duration = 5f;

+        GameObject cvsTime = this.gameObject.transform.Find("txtMesh").gameObject;        

+        cvsTime.SetActive(false);

+        _textMesh = cvsTime.GetComponent<TextMesh>();

