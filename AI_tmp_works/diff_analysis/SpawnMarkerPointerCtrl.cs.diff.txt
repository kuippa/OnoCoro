Change Type: significant_change
ILSpy: g:\unity\OnoCoro2026\Assets\Recovery\.Editor\ILspy_CS\SpawnMarkerPointerCtrl.cs
Scripts: g:\unity\OnoCoro2026\Assets\Scripts\UI\SpawnMarkerPointerCtrl.cs
================================================================================

--- SpawnMarkerPointerCtrl.cs+++ SpawnMarkerPointerCtrl.cs@@ -1,176 +1,144 @@-// Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
-// SpawnMarkerPointerCtrl
-using TMPro;
+using System.Collections;
+using System.Collections.Generic;
+using CommonsUtility;
+using Unity.VisualScripting;
 using UnityEngine;
-using UnityEngine.AI;
 using UnityEngine.InputSystem;
+using UnityEngine.EventSystems;
 
 public class SpawnMarkerPointerCtrl : MonoBehaviour
 {
-	public static SpawnMarkerPointerCtrl instance;
+    public static SpawnMarkerPointerCtrl instance = null;
+    private static GameObject _marker = null;
+    private float _time = 0.0f;
+    private const float _TIME_INTERVAL = 0.05f;
+    private const float _MARKER_Y_OFFSET = 0.08f;
 
-	private static GameObject _marker;
+    private void RayCastPointer()
+    {
+        // マウスがヒットした地面の座標を取得
+        Vector2 mousePosision = Mouse.current.position.ReadValue();
+        Ray PointRay = Camera.main.ScreenPointToRay(mousePosision);
+        RaycastHit hit;
+        if (Physics.Raycast(PointRay, out hit, GlobalConst.UI_RAYCAST_MAX_DISTANCE))
+        {
+            if (hit.collider.gameObject.tag != GameEnum.LayerType.Ground.ToString())
+            {
+                // Debug.Log("hit.collider.gameObject.tag: " + hit.collider.gameObject.tag);
+                return;
+            }
 
-	private float _time;
+            if (!isNavMeshHit(hit.point))
+            {
+                return;
+            }
 
-	private const float _TIME_INTERVAL = 0.05f;
+            // プレイヤー位置から距離が指定マス以上離れていたら抜ける
+            Vector3 playerPos = GameObject.FindWithTag(GameEnum.UnitType.Player.ToString()).transform.position;
+            if (Vector3.Distance(hit.point, playerPos) > GlobalConst.UI_RAYCAST_MAX_DISTANCE)
+            {
+                // Debug.Log("hit.point: " + hit.point + " Player.position: " + GameObject.FindWithTag(EnemyEnum.UnitType.Player.ToString()).transform.position);
+                return;
+            }
+            Vector3 markerPos = hit.point;
+            markerPos.y += _MARKER_Y_OFFSET;
+            // マーカーの座標をマウスの座標にする
+            this.transform.position = markerPos;
+        }
+    }
 
-	private const float _MARKER_Y_OFFSET = 0.08f;
+    private static bool isNavMeshHit(Vector3 point)
+    {
+        UnityEngine.AI.NavMeshHit hit;
+        if (UnityEngine.AI.NavMesh.SamplePosition(point, out hit, 1.0f, UnityEngine.AI.NavMesh.AllAreas))
+        {
+            return true;
+        }
+        return false;
+    }
 
-	private void SetPositionTMP(Vector3 pos)
-	{
-		GameObject gameObject = base.transform.Find("tmp_posi").gameObject;
-		if (!(gameObject == null))
-		{
-			TextMeshPro component = gameObject.GetComponent<TextMeshPro>();
-			if (!(component == null))
-			{
-				component.text = pos.x.ToString("F1") + ", " + pos.y.ToString("F1") + ", " + pos.z.ToString("F1");
-			}
-		}
-	}
+    internal Vector3 GetMarkerPosition()
+    {
+        return transform.position;
+    }
 
-	private Quaternion GetMarkerRotation()
-	{
-		Quaternion quaternion = base.transform.rotation;
-		if (quaternion == Quaternion.identity)
-		{
-			Vector3 playerPosition = GetPlayerPosition();
-			Vector3 position = base.transform.position;
-			Vector3 vector = playerPosition - position;
-			vector.y = 0f;
-			quaternion = Quaternion.LookRotation(vector * -1f);
-		}
-		return quaternion;
-	}
+    internal Vector3 SetMarkerPosition(Vector3 pos)
+    {
+        return transform.position = pos;
+    }
 
-	private void RayCastPointer()
-	{
-		Vector2 vector = Mouse.current.position.ReadValue();
-		Ray ray = Camera.main.ScreenPointToRay(vector);
-		int layerMask = ~LayerMask.GetMask(GameEnum.LayerType.AreaIgnoreRaycast.ToString());
-		if (Physics.Raycast(ray, out var hitInfo, 20f, layerMask))
-		{
-			if (!(hitInfo.collider.gameObject.tag != GameEnum.LayerType.Ground.ToString()) && isNavMeshHit(hitInfo.point))
-			{
-				Vector3 point = hitInfo.point;
-				point.y += 0.08f;
-				base.transform.position = point;
-				base.transform.rotation = GetMarkerRotation();
-				SetPositionTMP(point);
-				IsMarkerFarFromPlayer();
-			}
-		}
-		else if (IsMarkerFarFromPlayer())
-		{
-			Debug.Log("IsMarkerFarFromPlayer: " + IsMarkerFarFromPlayer());
-			SetMarkerActive(isActive: false);
-		}
-	}
+    internal static void SetMarkerActive(bool isActive)
+    {
+        if (_marker.gameObject.activeSelf != isActive)
+        {
+            _marker.gameObject.SetActive(isActive);
+        }
+    }
 
-	private static bool isNavMeshHit(Vector3 point)
-	{
-		if (NavMesh.SamplePosition(point, out var _, 10f, -1))
-		{
-			return true;
-		}
-		return false;
-	}
+    internal static bool IsMarkerActive()
+    {
+        // Item選択がOffの場合はマーカーを非表示にする
+        if (!ItemAction.IsItemSelected())
+        {
+            SetMarkerActive(false);
+            return false;
+        }
+        return _marker.gameObject.activeSelf;
+    }
 
-	private static Vector3 GetPlayerPosition()
-	{
-		return GameObject.FindWithTag(GameEnum.UnitType.Player.ToString()).transform.position;
-	}
 
-	internal static Vector3 GetMarkerPosition()
-	{
-		if (_marker == null)
-		{
-			return GetPlayerPosition();
-		}
-		return _marker.transform.position;
-	}
+    internal static Quaternion GetMarkerRotateAngle()
+    {
+        return _marker.transform.rotation;
+    }
 
-	internal static void SetMarkerActive(bool isActive)
-	{
-		if (!(_marker == null) && _marker.gameObject.activeSelf != isActive)
-		{
-			if (isActive)
-			{
-				_marker.transform.rotation = Quaternion.identity;
-			}
-			_marker.gameObject.SetActive(isActive);
-		}
-	}
 
-	private static bool IsMarkerFarFromPlayer()
-	{
-		if (Vector3.Distance(GetMarkerPosition(), GetPlayerPosition()) > 20f)
-		{
-			return true;
-		}
-		return false;
-	}
+    internal static void RotateMarker(float moveVec)
+    {
+        if (moveVec < 0) {
+            _marker.transform.Rotate(0, 30, 0);
+        }
+        else
+        {
+            _marker.transform.Rotate(0, -30, 0);
+        }
+    }
 
-	internal static bool IsMarkerActive()
-	{
-		if (!ItemAction.IsItemSelected())
-		{
-			SetMarkerActive(isActive: false);
-			return false;
-		}
-		return _marker.gameObject.activeSelf;
-	}
+    void OnDestory()
+    {
+        // Debug.Log(this.GetType().FullName + " " + System.Reflection.MethodBase.GetCurrentMethod().Name);
+        if (instance == this)
+        {
+            instance = null;
+        }
+    }
 
-	internal static Quaternion GetMarkerRotateAngle()
-	{
-		if (!IsMarkerActive())
-		{
-			return Quaternion.identity;
-		}
-		return _marker.transform.rotation;
-	}
 
-	internal static void RotateMarker(float moveVec)
-	{
-		if (moveVec < 0f)
-		{
-			_marker.transform.Rotate(0f, 30f, 0f);
-		}
-		else
-		{
-			_marker.transform.Rotate(0f, -30f, 0f);
-		}
-	}
+    void Awake()
+    {
+        // Debug.Log(this.GetType().FullName + " " + System.Reflection.MethodBase.GetCurrentMethod().Name);
+        if (instance == null)
+        {
+            instance = this;
+        }
+        _marker = this.gameObject;
+        SetMarkerActive(false);
+    }
 
-	private void OnDestory()
-	{
-		if (instance == this)
-		{
-			instance = null;
-		}
-	}
-
-	private void Awake()
-	{
-		if (instance == null)
-		{
-			instance = this;
-		}
-		_marker = base.gameObject;
-		SetMarkerActive(isActive: false);
-	}
-
-	private void Update()
-	{
-		_time += Time.deltaTime;
-		if (_time > 0.05f)
-		{
-			if (IsMarkerActive())
-			{
-				RayCastPointer();
-			}
-			_time = 0f;
-		}
-	}
+    // TODO: 
+    // [System.Serializable]
+    // public class MyEvent : UnityEvent { }
+    // などでイベントを定義して、イベント・ドリブンにする？
+    void Update()
+    {
+        _time += Time.deltaTime;
+        if (_time > _TIME_INTERVAL)
+        {
+            if (IsMarkerActive())
+            {
+                RayCastPointer();
+            }
+            _time = 0;
+        }
+    }
 }


================================================================================
Significant Changes: 253
-	public static SpawnMarkerPointerCtrl instance;

+    public static SpawnMarkerPointerCtrl instance = null;

+    private static GameObject _marker = null;

+    private float _time = 0.0f;

+    private const float _TIME_INTERVAL = 0.05f;

+    private const float _MARKER_Y_OFFSET = 0.08f;

-	private static GameObject _marker;

+    private void RayCastPointer()

+    {

+        Vector2 mousePosision = Mouse.current.position.ReadValue();

+        Ray PointRay = Camera.main.ScreenPointToRay(mousePosision);

+        RaycastHit hit;

+        if (Physics.Raycast(PointRay, out hit, GlobalConst.UI_RAYCAST_MAX_DISTANCE))

+        {

+            if (hit.collider.gameObject.tag != GameEnum.LayerType.Ground.ToString())

+            {

+                return;

+            }

-	private float _time;

+            if (!isNavMeshHit(hit.point))

